@startuml

' Core Components
class Simulation {
  - current_time: float
  - time_step: float
  - network: Network
  - matrices: DecisionMatrices
  - strategy: PowerStateStrategy
  - matrix_history: List
  - is_paused: bool
  + run() -> float
  + step() -> bool
  + reset()
  + set_strategy(strategy: PowerStateStrategy)
  + initialize_default_nodes()
  + set_nodes(node_type: type, count: int)
  + optimize(num_iterations: int) -> tuple[float, list[float]]
}

class DecisionMatrices {
  - matrices: Dict[MatrixType, ndarray]
  + generate_coverage_matrix(network: Network)
  + generate_request_matrix(num_requests: int, num_steps: int)
  + generate_power_matrix(num_devices: int, num_steps: int, strategy: PowerStateStrategy)
  + update_assignment_matrix(network: Network)
  + get_matrix(name: MatrixType) -> ndarray
  + set_matrix(name: MatrixType, matrix: ndarray)
  + get_snapshot() -> Dict[MatrixType, ndarray]
}

abstract class PowerStateStrategy {
  + {abstract} generate_power_matrix(num_devices: int, num_steps: int) -> ndarray
  + {abstract} get_name() -> str
}

class AllOnStrategy extends PowerStateStrategy {
  + generate_power_matrix(num_devices: int, num_steps: int) -> ndarray
  + get_name() -> str
}

class RandomStrategy extends PowerStateStrategy {
  - probability: float
  + generate_power_matrix(num_devices: int, num_steps: int) -> ndarray
  + get_name() -> str
}

enum MatrixType {
  COVERAGE_ZONE = "A"
  POWER_STATE = "B"
  REQUEST = "K"
  ASSIGNMENT = "X"
}

class Network {
  - nodes: List[BaseNode]
  - communication_links: List[CommunicationLink]
  + count_nodes_by_type(node_type: type) -> int
  + add_node(node: BaseNode)
  + get_compute_nodes() -> List[BaseNode]
  + route_request(request: Request) -> bool
  + tick(time: float)
}

abstract class BaseNode {
  # id: int
  # position: Position
  # state: bool
  # antennas: List[Antenna]
  # processing_power: float
  # processing_queue: List[Request]
  + turn_on()
  + turn_off()
  + add_antenna(type: str, gain: float)
  + get_compatible_antenna(other: Antenna) -> Optional[Antenna]
  + can_process(request: Request) -> bool
  + process_requests(time: float)
}

class Position {
  + coords: ndarray
  + x: float
  + y: float
  + distance_to(other: Position) -> float
}

class Antenna {
  - type: str
  - gain: float
  + is_compatible_with(other: Antenna) -> bool
}

class BaseStation extends BaseNode {
  - processing_power: float = 50.0
}

class HAPS extends BaseNode {
  - battery_capacity: float = 1000
  - processing_power: float = 40.0
}

class LEO extends BaseNode {
  - current_angle: float
  - angular_speed: float
  - processing_power: float = 30.0
  + update_position(time: float)
}

class UserDevice extends BaseNode {
  - current_requests: List[Request]
  + spawn_request(tick: int, target: BaseNode) -> Request
}

class CommunicationLink {
  - node_a: BaseNode
  - node_b: BaseNode
  - total_bandwidth: float
  - signal_power: float
  - carrier_frequency: float
  - transmission_queue: List[Request]
  + calculate_capacity() -> float
  + add_to_queue(request: Request)
  + tick(time: float)
}

class Request {
  - id: int
  - current_node: BaseNode
  - target_node: BaseNode
  - status: RequestStatus
  - size: float
  - priority: Priority
  - path: List[BaseNode]
  - path_index: int
  + update_status(new_status: RequestStatus)
}

enum RequestStatus {
  CREATED
  IN_TRANSIT
  IN_PROCESSING_QUEUE
  PROCESSING
  COMPLETED
}

' Relationships
Simulation *-- Network
Simulation *-- DecisionMatrices
Simulation o-- PowerStateStrategy

DecisionMatrices *-- MatrixType

Network o-- "1..*" BaseNode
Network o-- "0..*" CommunicationLink

BaseNode *-- Position
BaseNode o-- "1..*" Antenna
BaseNode o-- "0..*" Request

CommunicationLink o-- "0..*" Request

@enduml