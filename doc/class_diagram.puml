@startuml

' Core Components
class Simulation {
  - current_time: float
  - time_step: float
  - network: Network
  - matrices: DecisionMatrices
  - power_strategy: PowerStateStrategy
  - assignment_strategy: AssignmentStrategy
  - matrix_history: List
  - is_paused: bool
  + run() -> float
  + step() -> bool
  + reset()
  + set_power_strategy(strategy: PowerStateStrategy)
  + set_assignment_strategy(strategy: AssignmentStrategy)
  + initialize_default_nodes()
  + set_nodes(node_type: type, count: int)
  + evaluate_qos_satisfaction() -> float
}

class DecisionMatrices {
  - matrices: Dict[MatrixType, ndarray]
  + generate_coverage_matrix(network: Network)
  + generate_request_matrix(num_requests: int, num_steps: int)
  + generate_power_matrix(num_devices: int, num_steps: int, strategy: PowerStateStrategy)
  + update_assignment_matrix(network: Network)
}

' Strategy Hierarchy
abstract class PowerStateStrategy {
  + {abstract} generate_power_matrix(num_devices: int, num_steps: int) -> ndarray
  + get_name() -> str
}

abstract class AssignmentStrategy {
  + {abstract} select_compute_node(request: Request, nodes: List[BaseNode]) -> BaseNode
  + get_name() -> str
}

' Power State Implementations
class AllOnStrategy extends PowerStateStrategy
class RandomPowerStrategy extends PowerStateStrategy
class MatrixPowerStrategy extends PowerStateStrategy {
  - power_matrix: ndarray
  + set_matrix(matrix: ndarray)
  + get_matrix() -> ndarray
}

' Assignment Implementations
class TimeGreedyAssignment extends AssignmentStrategy
class EnergyGreedyAssignment extends AssignmentStrategy
class ClosestNodeAssignment extends AssignmentStrategy
class HAPSOnlyAssignment extends AssignmentStrategy
class RandomAssignment extends AssignmentStrategy

' Network Components
class Network {
  - nodes: List[BaseNode]
  - communication_links: List[CommunicationLink]
  + add_node(node: BaseNode)
  + get_compute_nodes() -> List[BaseNode]
  + route_request(request: Request) -> bool
  + tick(time: float)
  + get_total_energy_consumed() -> float
}

abstract class BaseNode {
  # node_id: int
  # position: Position
  # state: bool
  # antennas: List[Antenna]
  # energy_consumed: float
  # processing_queue: List[Request]
  + set_state(state: bool)
  + add_antenna(type: str, gain: float)
  + can_process(request: Request) -> bool
  + tick(time: float)
}

class Position {
  + x: float
  + y: float
  + distance_to(other: Position) -> float
}

class Antenna {
  - type: str
  - gain: float
  + is_compatible_with(other: Antenna) -> bool
}

class BaseStation extends BaseNode {
  - processing_frequency: float
}

class HAPS extends BaseNode {
  - battery_capacity: float
  - processing_frequency: float
  - transmission_power: float
}

class LEO extends BaseNode {
  - current_angle: float
  - angular_speed: float
  - battery_capacity: float
  + update_position(time: float)
}

class UserDevice extends BaseNode {
  - current_requests: List[Request]
  + add_request(request: Request)
}

class CommunicationLink {
  - node_a: BaseNode
  - node_b: BaseNode
  - transmission_queue: List[Request]
  + calculate_capacity() -> float
  + add_to_queue(request: Request)
  + tick(time: float)
}

' Optimizers
abstract class Optimizer {
  # simulation: Simulation
  # population_size: int
  # max_generations: int
  + {abstract} optimize() -> PowerStateStrategy
  # evaluate_fitness(strategy: PowerStateStrategy) -> float
}

class GeneticOptimizer extends Optimizer {
  - crossover_rate: float
  - mutation_rate: float
  + optimize() -> PowerStateStrategy
  - encode_strategy() -> ndarray  ' Converts strategy to chromosome
  - decode_chromosome(chromosome: ndarray) -> PowerStateStrategy
}

enum MatrixType {
  COVERAGE_ZONE
  POWER_STATE
  REQUEST
  ASSIGNMENT
}

' Relationships
Simulation *-- Network
Simulation *-- DecisionMatrices
Simulation o-- PowerStateStrategy
Simulation o-- AssignmentStrategy
DecisionMatrices *-- MatrixType
Network o-- "1..*" BaseNode
Network o-- "0..*" CommunicationLink
BaseNode *-- Position
BaseNode o-- "1..*" Antenna
BaseNode o-- "0..*" Request
CommunicationLink o-- "0..*" Request
Optimizer o-- Simulation

@enduml