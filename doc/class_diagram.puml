@startuml

' Core Components
class Simulation {
  - current_time: float
  - time_step: float
  - network: Network
  - matrices: DecisionMatrices
  - power_strategy: PowerStateStrategy
  - assignment_manager: AssignmentManager
  - matrix_history: List
  - is_paused: bool
  + run() -> float
  + step() -> bool
  + reset()
  + set_power_strategy(strategy: PowerStateStrategy)
  + set_assignment_strategy(strategy: AssignmentStrategy)
  + initialize_default_nodes()
  + set_nodes(node_type: type, count: int)
  + evaluate_qos_satisfaction() -> float
  + run_with_assignment(assign_vector: List[int]) -> (float, float)
}

class AssignmentManager {
  - current_assignment_vector: List[int]
  - power_state_history: Dict[int, List[Tuple[float, bool]]]
  - min_idle_time: float
  + set_assignment_vector(vector: List[int])
  + get_assignment_for_request(req_id: int) -> int
  + get_current_vector() -> List[int]
  + derive_power_states(time: float)
  + should_power_on(node_id: int, time: float) -> bool
  + should_power_off(node_id: int, time: float) -> bool
}

class OptimizationProblem {
  - simulation: Simulation
  - n_requests: int
  - n_nodes: int
  + evaluate(x: ndarray) -> Tuple[float, float]
  + get_bounds() -> Tuple[ndarray, ndarray]
}

' Strategy Hierarchy
abstract class PowerStateStrategy {
  + {abstract} generate_power_matrix(num_devices: int, num_steps: int) -> ndarray
  + get_name() -> str
  + update_power_states(assignments: List[int], request_times: List[float])
}

abstract class AssignmentStrategy {
  + {abstract} select_compute_node(request: Request, nodes: List[BaseNode]) -> tuple[BaseNode, List[BaseNode], float]
  + get_name() -> str
}

' Power State Implementations
class AllOnStrategy extends PowerStateStrategy
class RandomStrategy extends PowerStateStrategy {
  - probability: float
}
class StaticRandomStrategy extends PowerStateStrategy

' Assignment Implementations
class TimeGreedyAssignment extends AssignmentStrategy {
  - network: Network
}
class EnergyGreedyAssignment extends AssignmentStrategy {
  - network: Network
}
class ClosestNodeAssignment extends AssignmentStrategy {
  - network: Network
}
class HAPSOnlyAssignment extends AssignmentStrategy {
  - network: Network
}
class RandomAssignment extends AssignmentStrategy {
  - network: Network
}

class AssignmentStrategyFactory {
  - _strategies: Dict[str, Type[AssignmentStrategy]]
  + get_strategy(strategy, network) -> AssignmentStrategy
  + register_strategy(name: str, strategy_class: Type[AssignmentStrategy])
  + available_strategies() -> list[str]
}

' Network Components
class Network {
  - nodes: List[BaseNode]
  - communication_links: List[CommunicationLink]
  - compute_nodes: List[BaseNode]
  - haps_nodes: List[HAPS]
  - base_stations: List[BaseStation]
  - leo_nodes: List[LEO]
  + add_node(node: BaseNode)
  + get_compute_nodes() -> List[BaseNode]
  + generate_request_path(source: BaseNode, target: BaseNode) -> List[BaseNode]
  + get_network_delay(request: Request, path: List[BaseNode]) -> float
  + tick(time: float)
  + get_total_energy_consumed() -> float
}

abstract class BaseNode {
  # node_id: int
  # position: Position
  # state: bool
  # antennas: List[Antenna]
  # energy_consumed: float
  # processing_queue: List[Request]
  # battery_capacity: float
  # processing_frequency: float
  # transmission_power: float
  + set_state(state: bool)
  + add_antenna(type: str, gain: float)
  + can_process(request: Request) -> bool
  + tick(time: float)
  + transmission_energy() -> float
  + processing_energy() -> float
}

class Position {
  + x: float
  + y: float
  + distance_to(other: Position) -> float
}

class Antenna {
  - antenna_type: str
  - gain: float
  + is_compatible_with(other: Antenna) -> bool
}

class BaseStation extends BaseNode {
  - k_const: float
}

class HAPS extends BaseNode {
  - k_const: float
  {static} + haps_altitude: float
  {static} + sky_visibility_angle: float
}

class LEO extends BaseNode {
  - current_angle: float
  - k_const: float
  {static} + leo_altitude: float
  {static} + leo_temperature: float
  + speed: float
  + angular_speed: float
  + is_visible: bool
}

class UserDevice extends BaseNode {
  - current_requests: List[Request]
  - path_loss_exponent: float
  - attenuation_coefficient: float
  - reference_length: float
  + add_request(request: Request)
  + assign_target_node(request: Request, target_node: BaseNode)
}

class CommunicationLink {
  - node_a: BaseNode
  - node_b: BaseNode
  - transmission_queue: List[Request]
  - signal_power: float
  - carrier_frequency: float
  - total_bandwidth: float
  + calculate_capacity() -> float
  + calculate_transmission_delay(request: Request) -> float
  + add_to_queue(request: Request)
  + tick(time: float)
}

enum MatrixType {
  COVERAGE_ZONE
  POWER_STATE
  REQUEST
  ASSIGNMENT
}

' Relationships
Simulation *-- Network
Simulation *-- DecisionMatrices
Simulation *-- AssignmentManager
Simulation o-- PowerStateStrategy
Simulation o-- AssignmentStrategy
DecisionMatrices *-- MatrixType
Network o-- "1..*" BaseNode
Network o-- "0..*" CommunicationLink
BaseNode *-- Position
BaseNode o-- "1..*" Antenna
BaseNode o-- "0..*" Request
CommunicationLink o-- "0..*" Request
AssignmentStrategyFactory ..> AssignmentStrategy
OptimizationProblem *-- Simulation

@enduml
