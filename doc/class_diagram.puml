@startuml

' Core Components
class Simulation {
  - current_time: float
  - time_step: float
  - network: Network
  - matrices: DecisionMatrices
  - strategy: OptimizationStrategy
  - matrix_history: List
  - is_running: bool
  + run(duration: float)
  + pause()
  + resume()
  + reset()
  + set_strategy(strategy: OptimizationStrategy)
  + initialize_default_nodes()
  + set_base_stations(num: int)
  + set_haps(num: int)
  + set_users(num: int)
}

class DecisionMatrices {
  - matrices: Dict[MatrixType, Matrix]
  + compute_coverage_zones()
  + generate_request_matrix()
  + update_assignment_matrix()
  + get_matrix(name: str|MatrixType): Matrix
  + set_matrix(name: str|MatrixType, matrix: Matrix)
  + get_snapshot(): Dict[MatrixType, ndarray]
}

abstract class OptimizationStrategy {
  # matrices: DecisionMatrices
  # network: Network
  + {abstract} optimize(matrix_history: List): Matrix
  + {abstract} get_name(): str
}

class AllOnStrategy extends OptimizationStrategy {
  + optimize(matrix_history: List): Matrix
  + get_name(): str
}

class RandomStrategy extends OptimizationStrategy {
  - probability: float
  + optimize(matrix_history: List): Matrix
  + get_name(): str
}

' Future strategies
class GeneticStrategy extends OptimizationStrategy {
}

class PSOStrategy extends OptimizationStrategy {
}

class QLearningStrategy extends OptimizationStrategy {
}

class Matrix {
  - data: ndarray
  - name: str
  + update(data: ndarray)
  + get_value(i: int, j: int): float
  + set_value(i: int, j: int, value: float)
  + apply_mask(mask: ndarray)
}

class Network {
  - nodes: List<NetworkNode>
  - communication_links: List<Link>
  + update(time: float)
  + add_node(node: NetworkNode)
  + remove_node(node: NetworkNode)
  + get_network_state(): Dict
}

' Network Components
abstract class NetworkNode {
  # id: int
  # position: Position
  # power_state: bool
  # power_consumption: float
  # antennas: List<Antenna>
  + turn_on()
  + turn_off()
  + is_active(): bool
  + get_power_consumption(): float
}

class Position {
  + x: float
  + y: float
  + distance_to(other: Position): float
}

class Antenna {
  - type: str
  - gain: float
  + is_compatible_with(other: Antenna): bool
}

' Network Nodes
class BaseStation extends NetworkNode {
  - coverage_radius: float
  + calculate_coverage(): List[Position]
}

class HAPS extends NetworkNode {
  - altitude: float
  - coverage_area: float
  + update_solar_charging()
}

class LEO extends NetworkNode {
  - current_angle: float
  - angular_speed: float
  + update_position(time: float)
}

class UserDevice extends NetworkNode {
  - request_probability: float
  + generate_request(): bool
}

' Communication
class Link {
  - source: NetworkNode
  - target: NetworkNode
  - bandwidth: float
  - signal_power: float
  + calculate_capacity(): float
}

enum MatrixType {
  COVERAGE_ZONE = "A"
  POWER_STATE = "B"
  REQUEST = "K"
  ASSIGNMENT = "X"
}

' Relationships
Simulation *-- Network
Simulation *-- DecisionMatrices
Simulation o-- OptimizationStrategy

DecisionMatrices *-- "4" Matrix
DecisionMatrices *-- MatrixType

OptimizationStrategy --> DecisionMatrices
OptimizationStrategy --> Network

Network o-- "1..*" NetworkNode
Network o-- "0..*" Link

NetworkNode *-- Position
NetworkNode o-- "1..*" Antenna

@enduml